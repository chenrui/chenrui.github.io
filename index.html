<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Less is more.">
<meta property="og:type" content="website">
<meta property="og:title" content="chenrui">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="chenrui">
<meta property="og:description" content="Less is more.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chenrui">
<meta name="twitter:description" content="Less is more.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>chenrui</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chenrui</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Less is more.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2018/design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rui Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenrui">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/2018/design-pattern/" itemprop="url">design pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T00:00:00+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h1><ul>
<li><p>依赖倒置原则</p>
<ul>
<li>高层模块(稳定)不应该依赖低层模块(变化)，二者都应该依赖于抽象(稳定)</li>
<li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)</li>
</ul>
</li>
<li><p>开放封闭原则</p>
<ul>
<li>对扩展开放，对更改封闭</li>
<li>类模块应该是可扩展的，但是不可修改</li>
</ul>
</li>
<li><p>单一职责原则</p>
<ul>
<li>一个类应该仅有一个引起它变化的原因</li>
</ul>
</li>
<li><p>Liskov替换原则</p>
<ul>
<li>子类必须能够替换他们的基类</li>
</ul>
</li>
<li><p>接口隔离原则</p>
<ul>
<li>针对接口编程而不是针对实现编程</li>
</ul>
</li>
<li><p>优先使用对象组合，而不是类继承</p>
</li>
<li><p>封装变化点</p>
</li>
</ul>
<h1 id="重构技法"><a href="#重构技法" class="headerlink" title="重构技法"></a>重构技法</h1><ul>
<li>静态 -&gt; 动态</li>
<li>早绑定 -&gt; 晚绑定</li>
<li>继承 -&gt; 组合</li>
<li>编译时依赖 -&gt; 运行时依赖</li>
<li>紧耦合 -&gt; 松耦合</li>
</ul>
<h1 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h1><p>软件专业分工之后的第一个结果是“框架与应用程序的划分”，组件协作模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。</p>
<h2 id="模板方法模式-template-method"><a href="#模板方法模式-template-method" class="headerlink" title="模板方法模式(template method)"></a>模板方法模式(template method)</h2><ul>
<li><p>问题<br>  在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有原因(框架与应用之间的关系)而无法和任务的整体结构同时实现。</p>
<p>  模板方法提供了一种模式，在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/template-method.png" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="策略模式-strategy"><a href="#策略模式-strategy" class="headerlink" title="策略模式(strategy)"></a>策略模式(strategy)</h2><ul>
<li><p>问题<br>  在软件构建过程中，某些对象使用的算法可能多种多样经常改变，如果将这些算法都编码到对象中，将会使对象异常复杂，而且有时候支持不使用的算法也是一个性能负担</p>
<p>  在运行时根据需要透明地更改对象的算法，将算法与对象本身解耦</p>
</li>
<li><p>定义<br>  定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/strategy.png" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="观察者模式-observer"><a href="#观察者模式-observer" class="headerlink" title="观察者模式(observer)"></a>观察者模式(observer)</h2><ul>
<li><p>问题<br>  需要为某些对象建立一种“通知依赖关系”——一个对象(目标对象)的状态发生改变，所有的依赖对象(观察者对象)都将得到通知。如果这样的依赖关系过于紧密，使得软件不能很好的抵御变化</p>
</li>
<li><p>定义<br>  定义对象间的一种一对多(变化)的依赖关系，以便当一个对象的状态放生改变时，所有依赖于它的对象都得到通知并自动更新</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/observer.gif" alt="Figure: overview"></p>
</li>
</ul>
<h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><p>在设计中，如果责任划分不清晰，使得继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码。这时候的关键是划清责任。</p>
<h2 id="装饰器模式-decorator"><a href="#装饰器模式-decorator" class="headerlink" title="装饰器模式(decorator)"></a>装饰器模式(decorator)</h2><ul>
<li><p>问题<br>  使对象的扩展功能能够根据需求来动态的实现，同时避免扩展功能的增多带来的子类膨胀问题。</p>
</li>
<li><p>定义<br>  动态(组合)地给一个对象增加一些额外的职责。就增加功能而言，decorator模式比生成子类(继承)更为灵活(消除重复代码&amp;减少子类个数)</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/decorator.gif" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="桥接模式-bridge"><a href="#桥接模式-bridge" class="headerlink" title="桥接模式(bridge)"></a>桥接模式(bridge)</h2><ul>
<li><p>问题<br>  对象本生具有多维度的变化，如跨平台。但又不能出现类数量爆炸性增长</p>
</li>
<li><p>定义<br>  将抽象部分(业务功能)与实现部分(平台实现)分离，使得他们可以独立变化</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/bridge.png" alt="Figure: overview"></p>
</li>
<li><p>bridge与strategy</p>
<p>  桥接模式不仅Implementor具有变化（ConcreteImplementor），而且Abstraction也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction与ConcreateImplementor之间松散耦合，它们仅仅通过Abstraction与Implementor之间的关系联系起来。强调Implementor接口仅提供基本操作，而Abstraction则基于这些基本操作定义更高层次的操作。</p>
</li>
</ul>
<h1 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h1><p>通过”对象创建”模式绕开new，来避免对象创建过程中所导致的紧耦合(依赖具体类)，从而支持对象创建的稳定。</p>
<h2 id="工厂方法模式-factory-method"><a href="#工厂方法模式-factory-method" class="headerlink" title="工厂方法模式(factory method)"></a>工厂方法模式(factory method)</h2><ul>
<li><p>问题</p>
<p>  在系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变换。通过一种封装机制来避免客户程序和这种具体对象创建工作的紧耦合</p>
</li>
<li><p>定义</p>
<p>  定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到了子类(目的：解耦，手段：接口/虚函数)</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/factory-method.gif" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="抽象工厂模式-abstract-factory"><a href="#抽象工厂模式-abstract-factory" class="headerlink" title="抽象工厂模式(abstract factory)"></a>抽象工厂模式(abstract factory)</h2><ul>
<li><p>问题</p>
<p>  在系统中，经常面临着一系列相互依赖的对象的创建工作，由于需求变化，往往存在更多系列对象的创建工作。通过一种封装机制来避免客户程序和这些具体对象创建工作的紧耦合</p>
</li>
<li><p>定义</p>
<p>  提供一个接口，让该接口负责创建一系列相关或者相互依赖的对象，无需指定他们具体的类</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/abstract-factory.gif" alt="Figure: overview"></p>
</li>
</ul>
<h1 id="接口隔离模式"><a href="#接口隔离模式" class="headerlink" title="接口隔离模式"></a>接口隔离模式</h1><p>在组件构建过程中，某些接口之间直接的依赖常常带来很多问题甚至根本无法实现。因此添加一层间接(稳定)接口，来隔离本来相互紧密关联的接口。</p>
<h2 id="外观模式-facade"><a href="#外观模式-facade" class="headerlink" title="外观模式(facade)"></a>外观模式(facade)</h2><ul>
<li><p>问题</p>
<p>  简化外部客户程序和系统间的交互接口，将外部程序的演化和内部子系统的变化之间的依赖相互解耦</p>
</li>
<li><p>定义</p>
<p>  为子系统中的一组接口提供一个一致(稳定)的界面，facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(服用)</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/fadace.png" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="代理模式-proxy"><a href="#代理模式-proxy" class="headerlink" title="代理模式(proxy)"></a>代理模式(proxy)</h2><ul>
<li><p>问题</p>
<p>  在面向对象系统中，有些对象由于某种原因(比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等)，直接访问会给使用者或系统结构带来很多麻烦</p>
</li>
<li><p>定义</p>
<p>  为其他对象提供一种代理以控制(隔离，使用接口)对这个对象的访问</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/proxy.gif" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="适配模式-adapter"><a href="#适配模式-adapter" class="headerlink" title="适配模式(adapter)"></a>适配模式(adapter)</h2><ul>
<li><p>问题</p>
<p>  由于应用环境的变化，常常需要将一些现存的对象放在心的环境中，但新环境要求的接口是这些现存对象不满足的。adapter模式用于应对这种迁移的变化</p>
</li>
<li><p>定义</p>
<p>  将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/adapter.png" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="中介模式-mediator"><a href="#中介模式-mediator" class="headerlink" title="中介模式(mediator)"></a>中介模式(mediator)</h2><ul>
<li><p>问题</p>
<p>  当出现多个对象相互关联交互的情况时，对象之间常常维持一种复杂的应用关系，如果遇到需求的变化，这种直接引用关系将面临不断的变化</p>
</li>
<li><p>定义</p>
<p>  用一个中介对象来封装一系列的对象交互(封装变化)。中介者使各对象不需要显示的相互引用(编译依赖-&gt;运行时依赖)，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/mediator.gif" alt="Figure: overview"></p>
</li>
</ul>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>组件构建过程中，某些对象的状态经常变化，状态模式是为了对这些变化进行管理，同时又维持高层模块的稳定</p>
<h2 id="状态机模式-state"><a href="#状态机模式-state" class="headerlink" title="状态机模式(state)"></a>状态机模式(state)</h2><ul>
<li><p>问题</p>
<p>  某些对象的状态如果改变，其行为也会随之发生变化。但高层模块并不关心具体行为的行为有何不同</p>
</li>
<li><p>定义</p>
<p>  允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/state.gif" alt="Figure: overview"></p>
</li>
</ul>
<h1 id="数据结构模式"><a href="#数据结构模式" class="headerlink" title="数据结构模式"></a>数据结构模式</h1><p>有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。将这些特定数据结构封装在内部，对外提供统一接口，来实现与特定数据结构无关的访问，是一种有效的解决方案</p>
<h2 id="组合模式-composite"><a href="#组合模式-composite" class="headerlink" title="组合模式(composite)"></a>组合模式(composite)</h2><ul>
<li><p>问题</p>
<p>   客户代码希望忽略组合对象与单个对象的不同</p>
</li>
<li><p>定义</p>
<p>  允许你将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/composite.gif" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="责任链模式-composite"><a href="#责任链模式-composite" class="headerlink" title="责任链模式(composite)"></a>责任链模式(composite)</h2><ul>
<li><p>问题</p>
<p>  一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显示指定，将必不可少地带来请求发送者与接受者的紧耦合</p>
</li>
<li><p>定义</p>
<p>  使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</p>
</li>
</ul>
<h1 id="行为变化模式"><a href="#行为变化模式" class="headerlink" title="行为变化模式"></a>行为变化模式</h1><p>组件行为的变化经常导致组件本身剧烈的变化。行为变化模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合</p>
<h2 id="命令模式-command"><a href="#命令模式-command" class="headerlink" title="命令模式(command)"></a>命令模式(command)</h2><ul>
<li><p>问题</p>
<p>  命令的请求者与执行者需要解耦，有时还需要对命令进行记录、撤销、事务等处理</p>
</li>
<li><p>定义</p>
<p>  命令的发送者和命令执行者有不同的生命周期。命令发送了并不是立即执行；命令需要进行各种管理逻辑；需要支持撤消\重做操作</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/command.gif" alt="Figure: overview"></p>
</li>
</ul>
<h2 id="访问模式-visitor"><a href="#访问模式-visitor" class="headerlink" title="访问模式(visitor)"></a>访问模式(visitor)</h2><ul>
<li><p>问题</p>
<p>  由于需求改变，某些类层次结构中常常需要增加新的方法，如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计</p>
</li>
<li><p>结构</p>
<p>  <img src="/posts/2018/design-pattern/visitor.png" alt="Figure: overview"></p>
</li>
</ul>
<h1 id="对象性能模式"><a href="#对象性能模式" class="headerlink" title="对象性能模式"></a>对象性能模式</h1><p>面向对象很好的解决了“抽象”问题，但是必不可免的付出一定代价，例如对象的增多，内存占用等。在某些情况下需要谨慎处理</p>
<h2 id="单例模式-singleton"><a href="#单例模式-singleton" class="headerlink" title="单例模式(singleton)"></a>单例模式(singleton)</h2><ul>
<li><p>问题</p>
<p>  系统中，经常有这样一些特殊的类，必须保证他们在系统中只存在一个实例才能确保它们的逻辑正确性、以及良好效率。</p>
</li>
</ul>
<h2 id="享元模式-flyweight"><a href="#享元模式-flyweight" class="headerlink" title="享元模式(flyweight)"></a>享元模式(flyweight)</h2><ul>
<li><p>问题</p>
<p>  系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行代价。</p>
</li>
<li><p>定义</p>
<p>  运用共享技术有效地支持大量细粒度的对象</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2018/k8s-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rui Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenrui">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/2018/k8s-network/" itemprop="url">kubernetes networking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-25T00:00:00+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><p>Pods是kubernetes中最基本的单元。它是由一个或多个容器组成，并且共享网络堆栈和其他资源比如磁盘。“共享网络堆栈”是什么？实际上它表示pod中所有的容器可以用localhost相互访问。如果一个容器运行nginx并且监听80端口，另外一个容器运行scrapyd它可以使用<a href="http://localhost:80" target="_blank" rel="noopener">http://localhost:80</a> 来访问第一个容器。但是它是如何工作的？来看一个典型例子:</p>
<p><img src="/posts/2018/k8s-network/container1.png" alt="Figure: overview"></p>
<p>从上往下我们有一个物理网络接口eth0。链接eth0的是一个网桥docker0，虚拟网络接口veth0链接在网桥docker0上。docker0和veth0在相同的网段(172.17.0.0/24)。docker0是veth0的默认网关。容器运行时只能看见veth0并且通过docker0和eth0与外面通信。现在运行第二个容器：</p>
<p><img src="/posts/2018/k8s-network/container2.png" alt="Figure: overview"></p>
<p>第二个容器获得一个新的虚拟网络接口veth1，链接到相同的网桥docker0。这个接口分配的IP地址为172.17.0.3。两个容器可以通过docker0相互通信。</p>
<p>在kubernetes Pod中，容器之间为了共享网络堆栈，docker在启动容器时并不会创建一个新的虚拟接口，而是共享一个存在的接口：</p>
<p><img src="/posts/2018/k8s-network/container3.png" alt="Figure: overview"></p>
<p>现在第二个容器看见的是veth0而不是veth1。外部通过172.17.0.2寻址这两个容器，内部则通过端口找到具体是哪一个容器。这意味着两个容器不能打开相同的端口。这一套流程可以充分利用解耦和容器隔离，同时又可以让容器间的协作在最简单的网络环境中进行。</p>
<p>Kubernetes实现这种模式是通过为每个Pod创建一个特殊的容器，唯一的目的就是为其他容器提供网络接口。当Pod被调度后，在Node上使用docker ps命令，你会发现至少会有一个”pause”的容器。这个容器除了sleep不做任何事情直到收到SIGTERM信号而退出。尽管这个”pause”容器不活跃，但它是Pod的核心用来提供虚拟网络接口，所有其他容器用它来相互通信并且链接外部网络：</p>
<p><img src="/posts/2018/k8s-network/container4.png" alt="Figure: overview"></p>
<h1 id="The-Pods-Network"><a href="#The-Pods-Network" class="headerlink" title="The Pods Network"></a>The Pods Network</h1><p>Kubernetes集群可以由多个节点组成，为了让不同节点上的Pod能相互通信，系统提供了两种方法：1. 分配一个全局的地址空间，每个节点上的网桥地址都属于这个空间并且是唯一的。2. 在网关上添加路由表，指定数据包如何被路由。虚拟网络接口、网桥、路由规则的组合被称为overlay network。</p>
<p><img src="/posts/2018/k8s-network/pod-network.png" alt="Figure: overview"></p>
<p>通常我们不需要手动添加路由表。当pod与另一个pod要通信时常常通过抽象的service来进行。</p>
<h1 id="services"><a href="#services" class="headerlink" title="services"></a>services</h1><p>Pod networking是很优雅的，但是它自己不足以创造一个稳定的系统。这是因为系统中pods的生命周期是短暂的。你可以使用pod的IP作为endpoint，但是当pod被重新创建时不能保证IP不会变化。</p>
<p>你可能意识到这是一个老问题，其标准的解决方案是：使用反向代理/负载均衡。客户端连接代理服务器，代理负责维护后端服务器健康状态并转发请求。这要求代理服务器是持久稳定的，并且必须有一个后端服务器列表，以及需要知道后端服务器的健康状态。Kubernetes中为满足这三个要求，定义了service的概念。</p>
<p>为了说明service是如何实现pod的负载均衡，我们使用deployment创建两个nginx的pods并暴露80端口</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line"><span class="attr">  template:</span> <span class="comment"># create pods using pod definition in this template</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line">      <span class="comment"># unlike pod-nginx.yaml, the name is not included in the meta data as a unique name is</span></span><br><span class="line">      <span class="comment"># generated from the deployment name</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:latest</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f deployment.yaml </span></span><br><span class="line">deployment.apps "nginx-deployment" created</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">nginx-deployment-64ff85b579-cpftn   1/1       Running   0          2h        10.244.2.9   192.168.118.218</span><br><span class="line">nginx-deployment-64ff85b579-rbbmd   1/1       Running   0          2h        10.244.2.8   192.168.118.218</span><br></pre></td></tr></table></figure>
<p>通过在其他节点增加路由表，我们就可以访问到这两个pod。但是如果pod被重启或调度到其他节点，IP会发生变化导致客户端连接中断。为了避免这种情况我们创建一个service。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8080</span>          <span class="comment"># service</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span>      <span class="comment"># pod</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">清除iptables规则</span><br><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -F</span><br><span class="line">iptables -L -n</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl describe service</span></span><br><span class="line"></span><br><span class="line">Name:              my-service</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       kubectl.kubernetes.io/last-applied-configuration=&#123;"apiVersion":"v1","kind":"Service","metadata":&#123;"annotations":&#123;&#125;,"name":"my-service","namespace":"default"&#125;,"spec":&#123;"ports":[&#123;"port":8080,"protocol":"T...</span><br><span class="line">Selector:          app=nginx</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.105.214.79</span><br><span class="line">Port:              &lt;unset&gt;  8080/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.2.12:80,10.244.2.13:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Service-Networking"><a href="#Service-Networking" class="headerlink" title="Service Networking"></a>Service Networking</h2><p>每一个类型为ClusterIP的service都会被分配一个IP。它是servcie的默认类型，任何在集群中的pod都可以访问到。</p>
<p>像pod network一样service network也是虚拟的，但与pod不同的是：使用ifconfig命令查看，pod的ip地址是配置在实际的网卡上，而service的ip地址是完全虚拟的，它是路由规则配置而来。 kube-proxy的作用主要就是负责service的实现，具体来说，就是实现了内部从pod到service和外部的从node port向service的访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -S -t nat</span></span><br><span class="line">-A KUBE-SEP-32JLQPNPQ4QBMKXF -s 10.244.2.13/32 -m comment --comment "default/my-service:" -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-32JLQPNPQ4QBMKXF -p tcp -m comment --comment "default/my-service:" -m tcp -j DNAT --to-destination 10.244.2.13:80</span><br><span class="line">-A KUBE-SEP-JP7GPWZSV5GSOB6Q -s 10.244.2.12/32 -m comment --comment "default/my-service:" -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-JP7GPWZSV5GSOB6Q -p tcp -m comment --comment "default/my-service:" -m tcp -j DNAT --to-destination 10.244.2.12:80</span><br><span class="line">-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.106.86.116/32 -p tcp -m comment --comment "default/my-service: cluster IP" -m tcp --dport 8080 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SERVICES -d 10.106.86.116/32 -p tcp -m comment --comment "default/my-service: cluster IP" -m tcp --dport 8080 -j KUBE-SVC-KEAUNL7HVWWSEZA6</span><br><span class="line">-A KUBE-SERVICES -m comment --comment "kubernetes service nodeports; NOTE: this must be the last rule in this chain" -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br><span class="line">-A KUBE-SVC-KEAUNL7HVWWSEZA6 -m comment --comment "default/my-service:" -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-JP7GPWZSV5GSOB6Q</span><br><span class="line">-A KUBE-SVC-KEAUNL7HVWWSEZA6 -m comment --comment "default/my-service:" -j KUBE-SEP-32JLQPNPQ4QBMKXF</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2018/kubernetes-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rui Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenrui">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/2018/kubernetes-overview/" itemprop="url">kubernetes overview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T00:00:00+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="kubernetes的组件"><a href="#kubernetes的组件" class="headerlink" title="kubernetes的组件"></a>kubernetes的组件</h1><h2 id="master上的组件"><a href="#master上的组件" class="headerlink" title="master上的组件"></a>master上的组件</h2><ol>
<li><p>kube-apiserver</p>
<p> 组件暴露了Kubernetes的API接口。它是k8s控制平面的前端。它被设计成水平扩展的，也就是可以通过部署多个实例来实现。</p>
</li>
<li><p>etcd</p>
<p> 存储所有的集群数据。</p>
</li>
<li><p>kube-scheduler</p>
<p> 监控新创建的并且还没有被分配到节点上的pods，为这些pods选择一个节点让他们运行。</p>
<p> 调度决策需要考虑的因素包括个人的和公共的资源需求，硬件/软件/策略约束，数据本地化，工作负载干扰以及运行期限。</p>
</li>
<li><p>kube-controller-manager</p>
<p> 在master上运行的控制器(通过apiserver来监控集群的状态)。逻辑上，每个控制器都是独立的进程，但为了降低复杂度，他们都运行在同一个进程内。这些控制器包括：</p>
<ul>
<li>Node Controller: 当节点下线时负责通知并作出响应</li>
<li>Replication Controller：为系统中的每个复制控制器对象维护正确数量的pods</li>
<li>Endpoints Controller: 填充endpoints对象(添加services和pods)</li>
<li>Service Account &amp; Token Controllers: 为新的namespace创建默认账号和API访问token</li>
</ul>
</li>
</ol>
<h2 id="node上的组件"><a href="#node上的组件" class="headerlink" title="node上的组件"></a>node上的组件</h2><ol>
<li><p>kubelet</p>
<p> 在集群的每个节点上运行的代理。它确保容器运行在pod中。</p>
<p> kubelet通过一套PodSpecs提供多种机制并确保在PodSpecs中的容器正常运行。kubelet不会管理那些不是由k8s创建的容器。</p>
</li>
<li><p>kube-proxy</p>
<p> kube-proxy通过维护主机上的网络规则和执行链接转发使k8s的服务抽象成为可能。</p>
</li>
<li><p>container runtime</p>
<p> 支持Docker，rkt等容器技术。</p>
</li>
</ol>
<h1 id="kubernetes-Master-Node-通信"><a href="#kubernetes-Master-Node-通信" class="headerlink" title="kubernetes Master-Node 通信"></a>kubernetes Master-Node 通信</h1><h2 id="Cluster-gt-Master"><a href="#Cluster-gt-Master" class="headerlink" title="Cluster -&gt; Master"></a>Cluster -&gt; Master</h2><p>从cluster到master的所有通信路径都在apiserver终止(master上的其他组件都没有被暴露远程服务)。apiserver监听远程连接(https:443)并且开启了一种或多种形式的客户端验证。</p>
<p>节点也应该提供公共根证书，这样他们可以安全的链接到apiserver。</p>
<p>pods想要链接到apiserver也可以通过服务账号安全的做到，当pod被实例化时，kubernetes会自动把证书和token注入其中。kubernetes服务配置了一个虚拟IP地址，该IP地址被重定向（通过kube-proxy）到apiserver上的HTTPS端点。</p>
<h2 id="Master-gt-Cluster"><a href="#Master-gt-Cluster" class="headerlink" title="Master -&gt; Cluster"></a>Master -&gt; Cluster</h2><p>从master(apiserver)到cluster主要有两条通信线路。第一种是从apiserver到kubelet，第二种是从apiserver到任意的node、pod或service，通过apiserver的代理功能。</p>
<ol>
<li><p>apiserver -&gt; kubelet</p>
<p> 链接从apiserver到kubelet用于：</p>
<ul>
<li>获取pods的日志</li>
<li>通过kubectl连接正在运行的pods</li>
<li><p>提供kubelet的端口转发功能</p>
<p>这些连接最终到达kubelet的HTTPS endpoints。默认情况下，apiserver不会验证kubelet的证书,如果运行在公网上，这可能会受到中间人攻击。</p>
</li>
</ul>
</li>
<li><p>apiserver -&gt; nodes, pods, services</p>
<p> 从apiserver到node, pod和service默认是HTTP通信的，因此不需要认证和加密。</p>
</li>
</ol>
<h1 id="kubernetes的对象"><a href="#kubernetes的对象" class="headerlink" title="kubernetes的对象"></a>kubernetes的对象</h1><p>kubernetes的对象在系统中是持久化的实体。系统使用这些实体来展示集群的状态。它可以描述的有：</p>
<ul>
<li>哪些集装箱的应用在哪个节点上运行</li>
<li>应用程序可使用的资源</li>
<li>应用程序如何运行的策略，例如重启策略，升级和失败容忍</li>
</ul>
<p>k8s对象是一个“意图的记录”，一旦创建了对象，系统将不断的工作以确保对象的存在。通过创建对象，有效的告诉了系统集群的理想状态。</p>
<h2 id="对象说明书和状态"><a href="#对象说明书和状态" class="headerlink" title="对象说明书和状态"></a>对象说明书和状态</h2><p>每个对象包含两个嵌套的对象字段来管理对象的配置：对象说明书和对象状态。你必须提供说明书以描述对象的理想状态-希望对象拥有的特征。状态描述了对象真实的状态。</p>
<p>例如，Deployment是个可以对象，它可以显示一个应用运行在集群中。当创建一个Deployment，需要设置说明书来指定你想要3个应用副本同时运行。k8s系统读取Deployment说明书并且启动3个实例。如果任意一个实例失败(状态改变)，系统通过进行修正来响应说明书和状态之间的差异，在这个例子中，启动一个replacement实例。</p>
<h2 id="描述对象"><a href="#描述对象" class="headerlink" title="描述对象"></a>描述对象</h2><p>当使用kubectl创建对象时，需要提供一个.yaml格式的文件用于描述对象信息。必须的字段有：</p>
<ul>
<li>apiVersion: 使用哪个API版本来创建对象</li>
<li>kind: 对象的类型</li>
<li>metadata: 帮助唯一识别对象的数据，包括name，UID和namespace</li>
<li>spec: 每个对象有不同的格式，具体参见API文档</li>
</ul>
<p>一个Deployment对象的yaml描述：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h1 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h1><p>Pod是k8s的基本组成部分——创建和部署k8s对象的最小最简单的单元。一个Pod表示集群中运行的一个进程。</p>
<p>一个Pod封装了一个或多个应用层容器，存储资源，唯一IP地址，以及管理容器如何运行的选项。</p>
<p>一个Pod代表一个部署单元：一个单独的应用实例，它可能由一个或几个紧密耦合和共享资源的容器组成。</p>
<p>Docker是Pod中最常见的容器运行环境，但是Pod还支持其他的container runtimes。</p>
<p>Pods设计成支持多个合作进程(containers)从而形成有凝聚力的服务单元。集群里在相同物理机或虚拟机中的Pod里的容器会自动的共同协作和共同调度。这些容器能共享资源和依赖关系,相互通信，协调何时以及怎样终止他们。</p>
<h2 id="Pod-Lifecycle"><a href="#Pod-Lifecycle" class="headerlink" title="Pod Lifecycle"></a>Pod Lifecycle</h2><ol>
<li><p>Pod phase</p>
<p> pod包含以下几个阶段：</p>
<ul>
<li>Pending: Pod已经被系统接收，但容器还没有创建。这包括在调度之前的时间以及下载镜像的时间，这可能需要花一些时间</li>
<li>Running：Pod已经被分配到了一个节点上，并且所有容器已创建。至少有一个容器在运行或正在启动或重启</li>
<li>Succeeded：Pod中所有容器已经成功终止并且不再重启</li>
<li>Failed：所有容器已经终止，并且至少有一个容器是异常终止的</li>
<li>Unknown：Pod的状态无法获取，通常由于通信问题导致的</li>
</ul>
</li>
<li><p>Pod conditions</p>
<p> Conditions用于描述Pod更详细的状态:</p>
<ul>
<li>PodScheduled: pod正处于调度中，但还没有被分配到具体node上，ip也没有绑定</li>
<li>Initaized：指定的init container已创建完毕</li>
<li>Ready：容器创建成功，可提供服务</li>
<li>Running：所有容器正常运行</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2018/amazon-dynamo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rui Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenrui">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/2018/amazon-dynamo/" itemprop="url">amazon dynamo system architecture</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-21T00:00:00+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="http://docs.basho.com/riak/kv/2.2.3/learn/dynamo/" target="_blank" rel="noopener">http://docs.basho.com/riak/kv/2.2.3/learn/dynamo/</a></p>
</blockquote>
<p>一个需要在生产环境中操作的存储系统的架构是非常复杂的。再加上数据持久化组件，系统需要具备扩展性和健壮性的负载均衡解决方案：成员和故障检测，故障恢复，同步复制，过载处理，状态转换，并发性和作业调度，请求编组，请求路由，系统监控和告警，配置管理。这里我们主要讨论Dynamo系统中核心的分布式技术：分区、复制、版本控制、成员、错误处理和扩展。</p>
<table>
<thead>
<tr>
<th style="text-align:left">问题</th>
<th style="text-align:center">使用技术</th>
<th style="text-align:center">好处</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">分区</td>
<td style="text-align:center">一致性hash</td>
<td style="text-align:center">增加扩展性</td>
</tr>
<tr>
<td style="text-align:left">写操作高可用</td>
<td style="text-align:center">在读时使用向量时钟解决冲突</td>
<td style="text-align:center">版本大小与更新速率解耦</td>
</tr>
<tr>
<td style="text-align:left">解决临时错误</td>
<td style="text-align:center">仲裁和隐士切换</td>
<td style="text-align:center">当一些副本不可用时提供高可用和耐用性保证</td>
</tr>
<tr>
<td style="text-align:left">从永久性故障中恢复</td>
<td style="text-align:center">Merkle trees</td>
<td style="text-align:center">在后台同步有分歧的副本</td>
</tr>
<tr>
<td style="text-align:left">成员和故障检测</td>
<td style="text-align:center">Gossip 协议</td>
<td style="text-align:center">保持对称，避免集中式存储成员和节点活跃度信息</td>
</tr>
</tbody>
</table>
<h2 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h2><p>Dynamo通过get()和put()来获取和存储对象。get(key)操作通过key来定位对象副本并且返回一个对象或者一个包含冲突版本和上下文的对象列表。put(key, context, object)操作通过key决定哪里的副本来存放对象，并且写入硬盘。上下文编码关于对象的系统元数据，这对调用者是透明的，并且会包含一些其他信息，比如对象的版本。上下文信息与对象一起存储以便于系统验证put请求中提供的上下文对象的有效性。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>Dynamo最关键的设计要求是它必须是可扩展的。这需要一种机制来动态的把数据划分到节点集上。Dynamo的分区方案依赖于一致hash算法， 以便在多个存储主机之间分配负载。在一致hash中, 哈希函数的输出范围被视为一个固定循环空间。系统中的每个节点都在这个空间内分配一个随机值, 代表它在环上的位置。每个数据项通过对数据项的key进行hash来标识，以确定在环上的位置并分配给节点，然后顺时针旋转以查找大于该数据项位置的第一个节点。这样每个节点只负责它自己和它的前置节点之间环的区域。</p>
<p>一致哈希的原理优势是节点的增减只影响临近节点，而其他节点则不受影响。</p>
<p>基本一致哈希算法有一些挑战。首先，在环上每个节点的随机的位置分配导致不均匀的数据和负载。其次，算法没有注意到节点性能的差异。为了解决这些问题，Dynamo修改了基本算法：不是把一个节点映射到环上的一个点，而是把每个节点分配到多个点。为达到这个目的，Dynamo使用了虚拟节点的概念。一个虚拟节点看起来像系统中的单个节点，但每个节点可以负责多个虚拟节点。当系统增加一个新的节点，它会被分配到环上的多个点上。</p>
<p><img src="/posts/2018/amazon-dynamo/riak-ring.png" alt="Figure: overview"></p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>为了高可用，每个数据项都会被复制到N个主机。假设key哈希后落在如下图环中的位置，那么由节点B存储数据项。如果副本个数N设置为3，从节点B开始，顺时针找出2个(N-1)节点C、D，将数据项复制到节点上。</p>
<p><img src="/posts/2018/amazon-dynamo/replication.png" alt="Figure: overview"></p>
<h2 id="数据版本控制"><a href="#数据版本控制" class="headerlink" title="数据版本控制"></a>数据版本控制</h2><p>Dynamo提供最终一致性，允许将更新异步传送到所有副本。put()调用可能在更新操作被所有副本应用前返回，这导致随后的get()调用不是获取的最新数据。</p>
<p>为了提供可用性和分区容忍，Dynamo将每次修改的结果视为一个新的不可变的数据版本。它允许系统中出现数据的多个版本。大多数情况，新版本包含了之前的版本，系统自己可以决定权威的版本(语法合并)。但是当出现故常时，可能存在版本分支，导致对象合并冲突。这种情况下，系统不能合并对象的多个版本，必须由客户端来解决冲突(语义合并)。</p>
<p>Dynamo使用向量时钟，为了捕获同一对象的不同版本之间的因果关系。向量时钟实际上是一个(节点，计数器)队列表。向量时钟与每个对象的每个版本相关联。如果第一个对象的时钟计数器小于等于所有节点上第二个对象的时钟计数器，那么表示第一个是第二个的祖先可以被丢弃。否则，两个版本被认为是有冲突的需要和解。</p>
<p>合并操作示意图：</p>
<p><img src="/posts/2018/amazon-dynamo/reconfliction.png" alt="Figure: overview"></p>
<ol>
<li>客户端在节点Sx上写入新对象D1，向量时钟为[Sx, 1]</li>
<li>此时客户端需要更新对象，假设在同一个节点上更新，那么向量时钟为D2[Sx, 2]。D2从D1下降，因此D1被覆盖，但是在其他节点上可能任然会有D1的副本。</li>
<li>假设在不同的节点Sy, Sz上同时更新了D2对象。此时系统中出现D3向量时钟为([Sx,2], [Sy,1])和D4向量时钟为([Sx,2], [Sz,1])两个版本的数据。</li>
<li>D3和D4之间没有因果关系，因此系统无法合并。这是需要交给客户端进行语义合并。新数据D5的向量时钟为([Sx,3], [Sy,1], [Sz,1])</li>
</ol>
<h2 id="GET和PUT"><a href="#GET和PUT" class="headerlink" title="GET和PUT"></a>GET和PUT</h2><p>Dynamon中的每个节点都可以处理客户端的get和put的任何key。有两种策略可以选择节点：1. 通过负载信息路由请求；2. 通过分区路由请求。</p>
<p>处理读写请求的节点被称为协调员，特别是优先列表中的前N个节点。如果请求通过负载均衡，那么请求可能被路由到环上的任意节点。那些不是优先列表中的节点收到请求后不会执行读写，而是转发请求到前N个节点。如果节点故障或不能访问，那么在列表中排名靠后的节点将被访问。</p>
<p>为了保持副本的一致性，Dynamo使用类似仲裁系统的一致性协议。这个协议有两个可配置值：R和W。R表示必须参与成功的读操作的最小节点个数。W表示必须参与成功写操作的最小节点个数。设置R+W&gt;N产生一个类似选举的系统。这种情况下，读(写)的延迟依赖于那个最慢的读(写)副本。为了提供更好的延迟性，R+W通常设置为小于N。</p>
<p>在接收到一个put请求后，协调员生成一个向量时钟并写入新版本。协调员把新版本发送给排名最高的可访问的N个节点。如果有W-1个节点返回响应那么写入成功。</p>
<p>收到get请求，协调员从排名最高的可访问的N个节点中获取数据的所有版本，并且等待R个节点的响应。如果协调员最终收集到多个版本的数据，它将返回所有版本不相关。有分歧的版本被合并，并取代当前的版本被回写。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2018/distributed-system-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rui Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenrui">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/2018/distributed-system-overview/" itemprop="url">Distributed system</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T00:00:00+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h1><p>一致性问题是许多分布式系统的核心。我们希望分布式系统的可靠性和性能, 而不必处理分配所带来的后果 (例如, 节点之间的分歧), 解决一致性问题, 就可以解决几个相关的更高级的问题, 如原子广播和原子提交。</p>
<p>影响分布式系统设计选择的两个不可能结果(FLP和CAP):</p>
<ul>
<li><p>FLP不可能结果</p>
<p>  FLP论证了在一个异步的分布式系统中，即是只是容忍一个进程的错误，也不存在一个一致性算法可以保证正确性。这个结论听起来很可怕，连一个进程的错误都无法容忍，更何况通常对于多个进程的分布式系统，只是容忍一个进程的错误是不够的，然而实际上它只是论证了最坏的情况。首先它的前提是建立在一个完全异步的不可靠环境假设下，实际上可以让系统稍微“可靠”一些，其次，它只是论证了即使仅仅要容忍一个进程的错误，一致性算法都存在着永远不结束的可能。</p>
<p>  这种不可能的结果很重要, 因为它强调了假设异步系统模型导致权衡：当消息传递的边界不能保证时，处理一致性问题的算法必须放弃安全或活跃度。</p>
</li>
<li><p>CAP原理</p>
<ul>
<li>一致性(Consistency)：所有节点在同一时间看到相同数据。</li>
<li>可用性(Availability)：节点故障不能影响继续运行。</li>
<li><p>分区容忍(Partition tolerance)：消息因为网络或节点故障丢失时系统继续运行。</p>
<p>同时满足所有属性的系统是不可能实现的，最多同时满足两个:</p>
<p><img src="/posts/2018/distributed-system-overview/cap.png" alt="Figure: overview"></p>
</li>
<li><p>CA(一致性+可用性)。需要非常严格的全体一致的协议，比如“两阶段提交”（2PC）。CA系统不允许网络错误或节点错误来保证一致性，一旦出现这样的问题，系统将自己变为只读状态确保可用性，但会拒绝所有新的写请求。</p>
</li>
<li>CP(一致性+分区容忍)。关注的是系统里大多数人的一致性协议，比如Paxos 算法。系统只需要保证大多数结点数据一致，少数节点在数据不同步时把自己的状态设为不可用。</li>
<li><p>AP(可用性+分区容忍)。允许数据存在多个副本，在不能达成一致时给出数据冲突，因此需要维护数据版本。</p>
<p>当存在分区时，强一致性保证就要求我们放弃高可用。这是因为当两个分区间不能通信而继续在他们上面接收写操作时，不能避免副本间的差异。</p>
<p>强一致性要求在执行每一个操作时都需要所有节点通信并达成一致。这导致高延时且影响性能。</p>
</li>
</ul>
</li>
</ul>
<p>一致性模型：</p>
<ul>
<li><p>强一致性模型(维护单个副本)</p>
<ul>
<li>线性一致性: 所有的操作必须在一个全局实时系统中原子执行。</li>
<li>顺序一致性: 所有的操作在各自节点上以某种顺序原子执行。</li>
</ul>
</li>
<li><p>弱一致性模型</p>
<ul>
<li>以客户端为中心的一致性：涉及客户端或会话概念的一致性。比如，客户端为中心一致性保证客户端永远不会看到旧数据。这通常是通过增加缓存来实现的，这样当客户端访问到包含旧数据的副本节点时，返回的是缓存数据而非副本节点上的数据。</li>
<li>因果一致性</li>
<li>最终一致性: 如果停止修改值，经过一段时间后，所有副本会在相同的值上达成一致。这意味着在这段时间内副本间是不一致的。</li>
</ul>
</li>
</ul>
<h1 id="时钟和顺序问题"><a href="#时钟和顺序问题" class="headerlink" title="时钟和顺序问题"></a>时钟和顺序问题</h1><ul>
<li><p>全局时钟假设所有时间在所有分布式节点中完美同步。这样可以使用时间戳来确定全局时序。但可能变成一个潜在异常的来源:比如用户意外的改变了某节点的时间，或者一个过时的机器加入集群，或者时间同步的平率不一致，都会导致难以追踪的异常。</p>
</li>
<li><p>本地时钟假设每个节点都有自己的时钟。意味着你不能使用本地时钟来定义一个远端的时间戳是否发生在一个本地时间戳之前还是之后，也就是说，不能把来自不同节点的时间戳作比较。</p>
</li>
<li><p>无时钟只有逻辑时间的概念。我们不使用时钟, 而是以其他方式跟踪因果关系。时间戳只是在一个点上状态的简写，所以我们可以使用计数器和通信来定义某件事是否发生在另一件事之前、之后或同时发生。</p>
</li>
</ul>
<p>时钟同步由网络延时和物理距离等因素影响，即使在多个节点间同步一个j简单的整数计数器也是一个挑战。虽然时间和顺序经常一起被讨论，但时间本身并不是很有用的属性。算法并不真正关心时间，而更多的是抽象的属性：1. 事件的因果顺讯；2. 故障检测(消息传递的上界值)；3. 一致的快照(在某个时间点系统的状态)。</p>
<p>时间/顺序/同步是否真的需要？这需要看情况。在某些用例中, 我们希望每个中间操作都要把系统从一个一致状态移动到另一个一致状态。例如, 在许多情况下, 我们希望数据库中的响应表示所有可用的信息, 我们希望避免处理系统返回不一致结果时可能发生的问题。</p>
<p>但在其他情况下，我们不需要那么多的时间/顺序/同步。例如，一个长时间运行的计算并且在结束前不真正关心系统所做的操作，那么只要保证答案正确就不需要太多的同步。</p>
<h1 id="强一致性的复制问题"><a href="#强一致性的复制问题" class="headerlink" title="强一致性的复制问题"></a>强一致性的复制问题</h1><p>假设我们有一些初始数据库, 并且客户端发出请求以更改数据库的状态。可以分为以下几个阶段：</p>
<ol>
<li>请求。 客户端向服务端发送请求</li>
<li>同步。发生同步复制</li>
<li>响应。返回结果给客户端</li>
<li>异步。发生异步复制</li>
</ol>
<p><img src="/posts/2018/distributed-system-overview/replication-both.png" alt="Figure: overview"></p>
<p>复制的基本方法分为同步和异步。从技术上分为单拷贝系统(防止分歧)和多主系统(有分歧风险)。</p>
<p>单拷贝系统的目的是“行为更像单系统”。当部分错误发生时，系统保证仅只有一份拷贝是有效的。而且系统保证复制总是一致的。主要的复制算法有：</p>
<ul>
<li><p>主从复制(Master/Slave or Primary/Backup)</p>
<p>  所有的更新操作都在主上进行，操作日志(或变更日志)通过网络发送到备份副本上。这里有两个方法：同步复制和异步复制。同步复制要求两条消息(“update” + “acknowledge receipt”)，异步复制只需要一条update消息。</p>
<p>  任何异步复制算法都只能提供弱持久性保证。像Mysql的复制延迟：备份节点总是至少落后主节点一次数据更新。如果主节点出错，那些还没有发送到备份节点的更新操作会丢失。</p>
<p>  同步复制保证在返回客户端前，写操作已存储到备份节点中——以等待其他副本响应为代价。即使这样也只能提供弱保证：当主节点收到写请求并发送给从节点，从节点处理后并返回ACK，此时主节点在收到ACK前失败。如果出现这样的情况，只能手动的进行处理。</p>
<p>  为了防止这种异常情况，我们需要添加另外的消息，例如两阶段提交协议(2PC).</p>
</li>
<li><p>两阶段提交(2PC)</p>
<p>  两阶段提交的消息流如下所示：</p>
  <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ Coordinator ]</span> -&gt; OK to commit?     <span class="string">[ Peers ]</span></span><br><span class="line">                &lt;- Yes / No</span><br><span class="line"><span class="string">[ Coordinator ]</span> -&gt; Commit / Rollback <span class="string">[ Peers ]</span></span><br><span class="line">                &lt;- ACK</span><br></pre></td></tr></table></figure>
<p>  第一阶段，协调者发送更新操作给所有的参与者。每个参与者执行更新并投票是否提交或终止。当投票提交，参与者要在临时区存储更新(预写记录)。在第二阶段完成前，更新被认为是临时的。</p>
<p>  第二阶段，协调者决定结果并通知每一个参与者。如果所有参与者都投票提交，更新被永久保存。</p>
</li>
<li><p>分区容忍算法</p>
<p>  网络分区是因为节点间因为网络问题而无法连接，但节点本身是活跃的，他们甚至可以收到客户端的请求。因此网络分区可能导致系统被分割为两个同时活动的分区。</p>
<ul>
<li><p>多数决定</p>
<p>  要求大多数节点，而不是全部节点(与2PC不同)投票同意更新。只要(N/2 + 1)个节点是正常的，那么系统就是可用的。当网络分区发生时，一个分区会包含大部分节点，而那些少数分区将停止处理写操作以防止分歧。</p>
</li>
<li><p>角色</p>
<p>  每个节点有不同的角色。比如在Paxos算法中，有一个领导节点负责协调操作，其他节点负责接收。</p>
</li>
<li><p>Epochs</p>
</li>
</ul>
</li>
</ul>
<h1 id="弱一致性算法"><a href="#弱一致性算法" class="headerlink" title="弱一致性算法"></a>弱一致性算法</h1><p>弱一致性算法允许副本间彼此存在分歧。这意味着没有严格定义的通信模式: 复制副本可以彼此分离, 但仍可继续使用并接受写入。例如这样的场景：</p>
<p>副本可能位于不同的数据中心中, 并且由于某种原因无法进行通信。每个副本在分区期间保持可用, 同时接受来自某组客户端的读取和写入。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[Clients]</span>   - &gt; <span class="string">[A]</span></span><br><span class="line"></span><br><span class="line">--- Partition ---</span><br><span class="line"></span><br><span class="line"><span class="string">[Clients]</span>   - &gt; <span class="string">[B]</span></span><br><span class="line"></span><br><span class="line">--- Partition ---</span><br><span class="line"></span><br><span class="line"><span class="string">[Clients]</span>   - &gt; <span class="string">[C]</span></span><br></pre></td></tr></table></figure></p>
<p>一段时间后, 分区会愈合, 副本服务器开始交换信息。他们从不同的客户端收到了不同的更新, 彼此有分歧, 所以需要进行某种和解。我们希望发生的是, 所有的副本聚合到相同的结果。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[A]</span> \</span><br><span class="line">    --&gt; <span class="string">[merge]</span></span><br><span class="line"><span class="string">[B]</span> /     |</span><br><span class="line">          |</span><br><span class="line"><span class="string">[C]</span> ----<span class="string">[merge]</span>---&gt; result</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>冲突检测和读取修复</p>
<p>  许复制副本发散的系统必须有一种最终调和两个不同值的方法。一般的方法有</p>
<ul>
<li>最后一个编写器获胜。如果两个编写者同时写入, 则只保留最慢的作者的值。</li>
<li>时间戳。名义上, 具有较大时间戳值的值获胜。但是, 如果时间不同步, 可能会发生许多奇怪的事情, 例如旧数据会覆盖较新的值。</li>
<li>版本号。版本号可能会避免与使用时间戳相关的一些问题。请注意, 当有多个版本存在时，可以准确跟踪因果关系的最小机制是向量时钟, 而不是版本号。</li>
<li><p>向量时钟。如图：</p>
<p>  <img src="/posts/2018/distributed-system-overview/vector_clock.png" alt="Figure: overview"></p>
<p>读取值时, 客户端会联系N节点的R , 并向它们询问键的最新值。它接收所有的响应, 丢弃严格较旧的值 (使用向量时钟值来检测此)。如果只有一个唯一的向量时钟 + 值对, 它将返回。如果有多个矢量时钟 + 值对被同时编辑 (例如不可比较), 则返回所有这些值。</p>
<p>从上面可以看出, 读取修复可能返回多个值。这意味着, 客户端/应用程序开发人员必须偶尔处理这些情况, 方法是根据某些用例特定条件选择一个值。</p>
</li>
</ul>
</li>
<li><p>同步复制</p>
<p>  由于对节点故障和网络分区具有容错性，当更换或部分恢复故障节点时，需要一种方法来处理在分区后重新加入群集的节点。</p>
<p>  复制副本同步用于在发生故障后使节点更新, 并定期同步复制副本。</p>
<p>  Gossip是同步复制副本的一种概率技术。通信模式 (例如, 哪个节点联系哪个节点) 未事先确定。相反，节点有一定几率(p)尝试与其他节点同步。每隔t秒，每个节点选择另一个节点进行通信。</p>
</li>
</ul>
<p>一致性保证薄弱的系统的另一种情况是一组客户端以某种顺序将消息发送到两个副本。因为没有强制执行单个总订单的协调协议, 所以消息可以以不同的顺序在两个副本中传递，即无序编程。</p>
<p>CRDT(convergent replicated datatypes)是一种数据结构, 用于提供始终收敛的数据类型, 只要它们看到相同的操作集 (按任意顺序)。</p>
<blockquote>
<p>资料</p>
<ul>
<li><a href="http://book.mixu.net/distsys/single-page.html" target="_blank" rel="noopener">分布式系统概览</a></li>
<li><a href="http://www.bailis.org/blog/safety-and-liveness-eventual-consistency-is-not-safe/" target="_blank" rel="noopener">最终一致性模型数据的安全性和活跃性</a></li>
<li><a href="http://hal.archives-ouvertes.fr/docs/00/39/79/81/PDF/RR-6956.pdf" target="_blank" rel="noopener">CRDTs</a></li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2018/microservice-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rui Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenrui">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/2018/microservice-overview/" itemprop="url">microservices</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T00:00:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>翻译 <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a></p>
</blockquote>
<h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><p>”Microservices(微服务)“ - 是众多软件架构中的一个概念。尽管我们倾向于忽略这件事，但这些软件系统的概念描述还是让我们越来越感兴趣。我们已经看到最近这几年许多软件工程使用了这种模式，并且到目前结果邻人满意，正因为如此它已成为建立企业级应用的默认模式。不幸的是，现在还没有很多的关于microservice的概念以及应该怎样去实现。</p>
<p>简单的说，Microservices架构是一种把单体应用开发为一套小型服务的方法，每个服务运行在自己独立的进程中并用轻量级的机制进行通信，通常是HTTP API。这些服务围绕着业务能力来建立并且可以通过自动化部署工具进行独立部署。这里极少限度的对这些服务进行集中式管理，并且服务可能使用的是不同的编程语言或者不同的数据存储技术。</p>
<p>在开始解释Microservices前有必要与单体应用服务进行比较：单体应用建立成一个单元，企业级应用一般包括三部分：客户端用户界面(由运行在用户HTML页面和JS组成，并运行在用户端的浏览器上)，数据库，以及服务端应用。服务端应用接收HTTP请求并执行业务逻辑，从数据库获取和更新数据，选择和填充HTML页面并发送到客户端浏览器。服务端应用是一个庞大单一的逻辑执行程序，在系统中任何的改变都会触发编译和发布一个新的版本。</p>
<p>建立一个系统最自然的方式就是像这样拥有一个庞大的服务。所有处理请求的逻辑都运行在单个进程，允许你使用编程语言基本特性将应用分割成类、方法和名字空间。你可以通过负载均衡手段运行多个实例来横向扩展这个庞大的服务。</p>
<p>单体应用是非常成功的，但越来越多的人感觉受到挫折——特别是越来越多的应用发布在了云端。更改周期被绑在了一起——应用中任何小的改变，都要求整个庞大的系统重新编译和发布。长此以往很难保持好的模块化，也不利于扩展。</p>
<p>这些挫折导致出现了微服务架构：用多套服务构建应用。服务之间是独立可扩展的，每个服务规定了固定的模块边界，甚至允许不同的服务使用不同的编程语言，他们也可以由不同的团队来管理。</p>
<p>我们没有说过Microservices是革命性的，它的设计原理根源是从Unix而来。我们认为很少有人能够深入理解微服务架构并且软件工程师能够很好的使用它。</p>
<h1 id="微服务特性"><a href="#微服务特性" class="headerlink" title="微服务特性"></a>微服务特性</h1><p>虽然没有正式的定义Microservices，但是我们可以尝试描述什么样的常用的架构特征适合这个标签。像这些常用的特征大纲，不是所有微服务架构都包含了所有的特征，但是我们真的希望更多的微服务架构展示出更多的特征。</p>
<h2 id="1-组件化的服务"><a href="#1-组件化的服务" class="headerlink" title="1. 组件化的服务"></a>1. 组件化的服务</h2><p>在我们进入软件行业这么长的时间里，有一种渴望是用插件化的组建来建立系统，就像我们看到的真实世界一样。在最近的这20年中，我们看到了重大进展，大量常用的软件库成为许多语言平台的一部分。</p>
<p>当谈论组件时我们陷入了如何定义组件构成的困境中。我们是这样定义的：组件是一个软件单元可以独立的升级或替换。</p>
<p>微服务架构使用软件库，但是组件化我们软件的主要方式是分解服务。我们定义软件库，是被链接到工程中并在内存中直接调用其函数，但服务是进程外的组建，它通过某种机制，如web请求或远程调用进行通信。</p>
<p>使用服务而不是软件库作为服务的一个最主要原因是服务是独立部署的。如果你的应用在一个进程中由许多软件库构成，任何一个组件的变化都会导致整个应用重新部署。但是如果应用已经分解成多个服务，只需要将有变化的服务重新发布。这也不是绝对的，一些改变会涉及到对外接口的变化，但是好的微服务架构始终致力于最小化改变通过紧密结合的服务边界和通信机制。</p>
<p>另一个使用服务作为组件的原因是有更多的明确的服务接口。大部分语言没有好的机制定义明确的公共接口。通常阻止客户端破坏组件的封装，导致组件之间过度耦合。服务通过明确的远程调用机制很容易的避免这个问题。使用服务也有一些缺点:远程调用比进程内调用消耗更大。</p>
<h2 id="2-围绕业务能力"><a href="#2-围绕业务能力" class="headerlink" title="2. 围绕业务能力"></a>2. 围绕业务能力</h2><p>当拆分一个大的应用时，管理者通常关注的是技术层面，分为UI部门、服务端部门和数据部门。当一个团队被这样拆分，即使简单的修改都会导致跨部门，增加沟通成本。聪明的团队会优化这种模式，他们仅仅关注业务逻辑在哪个应用中。</p>
<p>微服务的划分则不同，它是围绕业务能力来的。这样的服务重叠的实现了业务，包括用户接口，持久化存储和其他外部协作。所以整个团队是跨职能的，需要开发人员有全面的技能：用户体验、数据存储和项目管理。</p>
<h2 id="3-产品而非项目"><a href="#3-产品而非项目" class="headerlink" title="3. 产品而非项目"></a>3. 产品而非项目</h2><p>我们看到众多的应用开发努力使用项目模式：以交出一部分认为是完成了的软件为目的。软件开发完成后交给运维部门，项目组也就解散了。</p>
<p>微服务支持者希望避免这种模式，而用“团队拥有产品的整个生命周期”这种概念来代替。这个灵感来自于亚马逊提出的“你建立，你运行”的概念，开发团队对产品负责。这样带来的结果使开发人员注意到软件在产品中行为并且增加与用户的联系。</p>
<p>似乎没有理由单体应用不能达到相同的效果，但是更小力度的服务可以更容易的增进开发者与用户的关系。</p>
<h2 id="4-智能端点-endpoint-和哑管道"><a href="#4-智能端点-endpoint-和哑管道" class="headerlink" title="4. 智能端点(endpoint)和哑管道"></a>4. 智能端点(endpoint)和哑管道</h2><p>在建立不同进程之间的通信结构时, 我们看到了许多产品和方法, 它们强调通信机制本身需要智能化。这方面的一个很好的例子是企业服务总线 (ESB), 其中 ESB 通常是一个包含消息路由，编排、转换和应用业务规则的复杂设施。</p>
<p>微服务倾向于一种替代方法:智能端点和哑管道。以微服务建立的应用想要竟可能的解耦而又紧密联系——他们有自己的业务逻辑并且表现得像Unix系统中的过滤器——接收请求，执行逻辑，产生响应。服务间使用简单的RESTish协议而不是其他复杂的协议。</p>
<p>最常用的两种协议是 HTTP API和轻量级消息(RabbitMQ或ZeroMQ)。</p>
<p>在单体应用中，组件在进程中并且通过方法调用和函数调用进行通信。把一个单体应用变成微服务最大的问题在于改变通信模式。把内存中的方法调用变成RPC调用会导致冗余的通信而消耗性能。相反需要用粗粒度的通信替换细粒度通信。</p>
<h2 id="5-分权治理"><a href="#5-分权治理" class="headerlink" title="5. 分权治理"></a>5. 分权治理</h2><p>集中化管理的后果是在单一平台上的标准化。但经验表明，这种方法是有限的——不是每个问题都是一个钉子而每个解决方法都是一个锤子。我们更喜欢用正确的工具来完成任务，但在集中式的应用中使用不同的编程语言，这并不常见。</p>
<p>与其在纸上定义标准，建立微服务的团队更喜欢开发有用的工具，其他开发者也可以用它解决相同的问题。这些工具通常从现实中收获并且和其他团队共享。</p>
<h2 id="6-分散的数据管理"><a href="#6-分散的数据管理" class="headerlink" title="6. 分散的数据管理"></a>6. 分散的数据管理</h2><p>数据管理权利下放以多种不同方式呈现。在最抽象层面上，意味着系统之间的概念模型是不同的。这是大型企业常见的问题：销售视图与技术支持视图不同，销售视图中被称为客户的东西根本不可能出现在技术支持视图中。还有一些属性表示不同的语义。</p>
<p>这个问题在应用之间是很常见的，但也肯能发生在内部应用中，特别是应用被划分为单独的组件时。一种有用的方法是边界上下文的领域驱动设计(Domain Driven Design)概念。DDD将一个复杂的领域划分为多个有界的上下文，并映射出他们的关系。这样服务之间也加强了间隔。</p>
<p>微服务还分散了数据存储决策。集中式应用使用一个单一的数据库来持久化数据，但微服务喜欢让每个服务管理自己的数据库，或者同一个存储技术的多个实例，或者不同的存储系统。</p>
<p><img src="/posts/2018/microservice-overview/microservice-1.png" alt="Figure: overview"></p>
<p>分散管理需要对跨服务的数据更新的影响负责。处理更新的常用方法是使用事物来保证更新多个资源时的一致性。</p>
<p>使用事物有助于保持一致性，但会导致大量的时间耦合，这在多个服务间是有问题的。分布式事物是很难实现的，因此微服务架构强调服务间的少事务协调，明确认为最终一致性通过补偿操作来处理。</p>
<p>选择这种方式管理不一致性对许多开发团队是一个挑战，但它常常与业务实践相匹配。通常业务处理某种程度的不一致是为了快速响应需求，同时有一些可逆流程来处理错误。只要修复错误的成本低于为保持一致性带来的业务损失就值得权衡。</p>
<h2 id="7-故障设计"><a href="#7-故障设计" class="headerlink" title="7. 故障设计"></a>7. 故障设计</h2><p>使用服务作为组件的结果是应用需要设计容错机制以便忍受服务失败。任何服务调用都可能失败，客户端必须竟可能优雅的响应此问题。与集中式应用相比这是个缺点，因为它增加了复杂性。</p>
<p>由于服务可能在任何时候失败，因此很重要的一点是能够快速检测故障并在可能的情况下自动恢复。微服务应用非常重视对系统的实时监控，监控指标可以提供一个错误预警系统，触发开发团队跟进和调查。</p>
<blockquote>
<p>资料</p>
<ul>
<li>领域驱动设计：<a href="https://www.oschina.net/news/18245/what-is-domain-driven-design" target="_blank" rel="noopener">https://www.oschina.net/news/18245/what-is-domain-driven-design</a></li>
<li><a href="https://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="noopener">https://martinfowler.com/eaaDev/EventCollaboration.html</a></li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Rui Chen" />
          <p class="site-author-name" itemprop="name">Rui Chen</p>
           
              <p class="site-description motion-element" itemprop="description">Less is more.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rui Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
